flowchart TD
    A([ğŸš€ Start LeaderboardService]):::entry --> B{{ğŸ·ï¸ Extract leaderboard tag<br/>from scan_strategy_tag}}:::step
    B --> C{{ğŸ“¦ Initialize leaderboard store<br/>if missing}}:::storage
    C --> D[ğŸ” Iterate over normalized snapshots<br/>for each ticker]:::loop

    D --> E0{{âœ… Validate snapshot #40;Sanity checks#41;}}:::branch
    E0 -- Invalid --> E5([ğŸ›‘ Skip invalid snapshot]):::exit
    E0 -- Valid --> E1[ğŸ’¾ Store new snapshot<br/><i>storeSnapshot</i>]:::storage
    E1 --> E2[ğŸ“š Fetch recent history<br/><i>retrieveRecentSnapshots</i>]:::async
    E2 --> E3{{ğŸ“Š <b>Enough history for ticker?</b>}}:::branch
    E3 -- No --> E4([ğŸš« Skip ticker<br/>not enough data]):::exit

    E3 -- Yes --> F1[ğŸ§  Compute kinetics<br/>velocity, acceleration]:::compute
    F1 --> F2[ğŸ†• Create leaderboard entry<br/>init appearance count to 1]:::step
    F2 --> F3[ğŸ—‚ï¸ Add to batch map<br/>in-memory leaderboard map]:::step

    F3 --> M1[ğŸ“¥ Retrieve previous leaderboard<br/><i>retreiveLeaderboard</i>]:::async
    M1 --> M2A{{ğŸ†• Is leaderboard empty?}}:::branch
    M2A -- Yes --> M3[âš™ï¸ Set appearance count = 1<br/>for new tickers]:::step
    M2A -- No --> M2{{ğŸ”€ Merging with previous entries?}}:::branch

    M2 -- No --> M3
    M2 -- Yes --> M4[â™»ï¸ Update appearance counts<br/>increment for persistent/retained]:::step
    M4 --> M5[ğŸ“Œ Retain missing tickers<br/>from previous leaderboard]:::step
    M5 --> M6[âœ… Finalize appearance counts<br/>set to 1 if unseen]:::step

    M3 --> S1
    M6 --> S1

    S1[ğŸ“ˆ Compute momentum score<br/>velocity Ã— appearance + acceleration]:::compute
    S1 --> S2[ğŸ’¥ Add POP bonus if new<br/>score += popBonus]:::step
    S2 --> S3[ğŸ“‰ Apply decay score *= decayFactor ^ n-1]:::step

    S3 --> R1[ğŸ§® Sort by scores - DESC order]:::compute
    R1 --> R2[ğŸ… Assign ranks<br/>rank = index + 1]:::compute
    R2 --> R3([ğŸ“¤ Return ranked leaderboard]):::exit
    R3 --> H[ğŸ’¾ Persist leaderboard]:::storage
    H --> Z([âœ… Done]):::exit

    %% Styles
    classDef step fill:#e6ffcc,stroke:#008000,stroke-width:2px;
    classDef entry fill:#fffbe6,stroke:#ffb300,stroke-width:2px;
    classDef exit fill:#f5f5f5,stroke:#222,stroke-width:2px;
    classDef error fill:#fff0f0,stroke:#d00,stroke-width:2px;
    classDef compute fill:#e0f7fa,stroke:#006064,stroke-width:2px;
    classDef storage fill:#ffe6e6,stroke:#cc0000,stroke-width:2px;
    classDef loop fill:#f0f0f0,stroke:#888,stroke-dasharray: 5, 5;
    classDef async fill:#fffbe6,stroke:#ff9900,stroke-width:2px;
    classDef branch fill:#ffffff,stroke:#999999,stroke-dasharray: 3, 3;
